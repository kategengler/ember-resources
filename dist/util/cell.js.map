{"version":3,"file":"cell.js","sources":["../../src/util/cell.ts"],"sourcesContent":["import { tracked } from '@glimmer/tracking';\nimport { assert } from '@ember/debug';\n\nclass Cell<Value = unknown> {\n  @tracked declare current: Value;\n\n  constructor();\n  constructor(initialValue: Value);\n  constructor(initialValue?: Value) {\n    if (initialValue !== undefined) {\n      this.current = initialValue;\n    }\n  }\n\n  /**\n   * Toggles the value of `current` only if\n   * `current` is a boolean -- errors otherwise\n   */\n  toggle = () => {\n    assert(\n      `toggle can only be used when 'current' is a boolean type`,\n      typeof this.current === 'boolean' || this.current === undefined\n    );\n\n    (this.current as boolean) = !this.current;\n  };\n\n  /**\n   * Updates the value of `current`\n   * by calling a function that recieves the previous value.\n   */\n  update = (updater: (prevValue: Value) => Value) => {\n    this.current = updater(this.current);\n  };\n\n  /**\n   * Updates the value of `current`\n   */\n  set = (nextValue: Value) => {\n    this.current = nextValue;\n  };\n}\n\n/**\n * Small state utility for helping reduce the number of imports\n * when working with resources in isolation.\n *\n * The return value is an instance of a class with a single\n * `@tracked` property, `current`. If `current` is a boolean,\n * there is a `toggle` method available as well.\n *\n * For example, a Clock:\n *\n * ```js\n * import { resource, cell } from 'ember-resources';\n *\n * const Clock = resource(({ on }) => {\n *   let time = cell(new Date());\n *   let interval = setInterval(() => time.current = new Date(), 1000);\n *\n *   on.cleanup(() => clearInterval(interval));\n *\n *   let formatter = new Intl.DateTimeFormat('en-US', {\n *     hour: 'numeric',\n *     minute: 'numeric',\n *     second: 'numeric',\n *     hour12: true,\n *   });\n *\n *   return () => formatter.format(time.current);\n * });\n *\n * <template>\n *   It is: <time>{{Clock}}</time>\n * </template>\n * ```\n */\nexport function cell<Value = unknown>(initialValue?: Value): Cell<Value> {\n  if (initialValue !== undefined) {\n    return new Cell(initialValue as Value);\n  }\n\n  return new Cell();\n}\n"],"names":["Cell","_class","constructor","initialValue","_initializerDefineProperty","_descriptor","_defineProperty","assert","current","undefined","updater","nextValue","_applyDecoratedDescriptor","prototype","tracked","configurable","enumerable","writable","initializer","cell"],"mappings":";;;;;;AACsC,IAEhCA,IAAI,IAAAC,MAAA,GAAV,MAAMD,IAAI,CAAkB;EAK1BE,WAAWA,CAACC,YAAoB,EAAE;AAAAC,IAAAA,0BAAA,kBAAAC,WAAA,EAAA,IAAA,CAAA,CAAA;AAAAC,IAAAA,eAAA,iBAUzB,MAAM;AACbC,MAAAA,MAAM,CACH,CAAA,wDAAA,CAAyD,EAC1D,OAAO,IAAI,CAACC,OAAO,KAAK,SAAS,IAAI,IAAI,CAACA,OAAO,KAAKC,SAAS,CAChE,CAAA;AAEA,MAAA,IAAI,CAACD,OAAO,GAAe,CAAC,IAAI,CAACA,OAAO,CAAA;KAC1C,CAAA,CAAA;IAAAF,eAAA,CAAA,IAAA,EAAA,QAAA,EAMSI,OAAoC,IAAK;MACjD,IAAI,CAACF,OAAO,GAAGE,OAAO,CAAC,IAAI,CAACF,OAAO,CAAC,CAAA;KACrC,CAAA,CAAA;IAAAF,eAAA,CAAA,IAAA,EAAA,KAAA,EAKMK,SAAgB,IAAK;MAC1B,IAAI,CAACH,OAAO,GAAGG,SAAS,CAAA;KACzB,CAAA,CAAA;IA/BC,IAAIR,YAAY,KAAKM,SAAS,EAAE;MAC9B,IAAI,CAACD,OAAO,GAAGL,YAAY,CAAA;AAC7B,KAAA;AACF,GAAA;;AAEA;AACF;AACA;AACA;AAwBA,CAAC,GAAAE,WAAA,GAAAO,yBAAA,CAAAX,MAAA,CAAAY,SAAA,EAAA,SAAA,EAAA,CArCEC,OAAO,CAAA,EAAA;EAAAC,YAAA,EAAA,IAAA;EAAAC,UAAA,EAAA,IAAA;EAAAC,QAAA,EAAA,IAAA;EAAAC,WAAA,EAAA,IAAA;AAAA,CAAA,CAAA,GAAAjB,MAAA,CAAA,CAAA;AAuCV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASkB,IAAIA,CAAkBhB,YAAoB,EAAe;EACvE,IAAIA,YAAY,KAAKM,SAAS,EAAE;AAC9B,IAAA,OAAO,IAAIT,IAAI,CAACG,YAAY,CAAU,CAAA;AACxC,GAAA;EAEA,OAAO,IAAIH,IAAI,EAAE,CAAA;AACnB;;;;"}