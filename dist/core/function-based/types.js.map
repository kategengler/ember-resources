{"version":3,"file":"types.js","sources":["../../../src/core/function-based/types.ts"],"sourcesContent":["import type Owner from '@ember/owner';\n\nexport const INTERMEDIATE_VALUE = '__Intermediate_Value__';\nexport const INTERNAL = '__INTERNAL__';\n\nexport interface InternalFunctionResourceConfig<Value = unknown> {\n  definition: ResourceFunction<Value>;\n  type: 'function-based';\n  [INTERNAL]: true;\n}\n\nexport type Hooks = {\n  on: {\n    /**\n     * Optionally a function-resource can provide a cleanup function.\n     *\n     *\n     *  Example:\n     *  ```js\n     *  import { resource } from 'ember-resources';\n     *  import { TrackedObject } from 'tracked-built-ins';\n     *\n     *  const load = resource(({ on }) => {\n     *    let state = new TrackedObject({});\n     *    let controller = new AbortController();\n     *\n     *    on.cleanup(() => controller.abort());\n     *\n     *    fetch(this.url, { signal: controller.signal })\n     *      // ...\n     *\n     *    return state;\n     *  })\n     */\n    cleanup: (destroyer: Destructor) => void;\n  };\n  owner: Owner;\n};\n\n/**\n * Type of the callback passed to `resource`\n */\nexport type ResourceFunction<Value = unknown> = (hooks: Hooks) => Value | (() => Value);\n\n/**\n * The perceived return value of `resource`\n * This is a lie to TypeScript, because the effective value of\n * of the resource is the result of the collapsed functions\n * passed to `resource`\n */\nexport type ResourceFn<Value = unknown> = (hooks: Hooks) => Value;\n\nexport type Destructor = () => void;\nexport type Cache = object;\n"],"names":["INTERMEDIATE_VALUE","INTERNAL"],"mappings":"AAEO,MAAMA,kBAAkB,GAAG,yBAAwB;AACnD,MAAMC,QAAQ,GAAG;;;;"}