{"version":3,"file":"immediate-invocation.js","sources":["../../../src/core/function-based/immediate-invocation.ts"],"sourcesContent":["// @ts-ignore\nimport { createCache, getValue } from '@glimmer/tracking/primitives/cache';\nimport { associateDestroyableChild } from '@ember/destroyable';\n// @ts-ignore\nimport { capabilities as helperCapabilities, invokeHelper, setHelperManager } from '@ember/helper';\n\nimport type { Cache } from './types';\nimport type Owner from '@ember/owner';\n\ntype SpreadFor<T> = T extends Array<any> ? T : [T];\ntype ResourceFactory<Value = any, Args = any[]> = (...args: SpreadFor<Args>) => Value;\n\ninterface State {\n  cache: Cache;\n  fn: any;\n  args: any;\n  _?: any;\n}\n\nclass ResourceInvokerManager {\n  capabilities = helperCapabilities('3.23', {\n    hasValue: true,\n    hasDestroyable: true,\n  });\n\n  constructor(protected owner: Owner) {}\n\n  createHelper(fn: ResourceFactory, args: any): State {\n    /**\n     * This cache is for args passed to the ResourceInvoker/Factory\n     *\n     * We want to cache the helper result, and only re-inoke when the args\n     * change.\n     */\n    let cache = createCache(() => {\n      let resource = fn(...args.positional) as object;\n\n      return invokeHelper(cache, resource);\n    });\n\n\n    return { fn, args, cache, _: getValue(cache) };\n  }\n\n  /**\n   * getValue is re-called when args change\n   */\n  getValue({ cache }: State) {\n    let resource = getValue(cache);\n\n    associateDestroyableChild(cache, resource);\n\n    return getValue(resource);\n  }\n\n  getDestroyable({ cache }: State) {\n    return cache;\n  }\n\n  // createHelper(fn: AnyFunction, args: Arguments): State {\n  //   return { fn, args };\n  // }\n\n  // getValue({ fn, args }: State): unknown {\n  //   if (Object.keys(args.named).length > 0) {\n  //     let argsForFn: FnArgs<Arguments> = [...args.positional, args.named];\n\n  //     return fn(...argsForFn);\n  //   }\n\n  //   return fn(...args.positional);\n  // }\n\n  // getDebugName(fn: AnyFunction): string {\n  //   if (fn.name) {\n  //     return `(helper function ${fn.name})`;\n  //   }\n\n  //   return '(anonymous helper function)';\n  // }\n}\n\n/**\n * Allows wrapper functions to provide a [[resource]] for use in templates.\n *\n * Only library authors may care about this, but helper function is needed to \"register\"\n * the wrapper function with a helper manager that specifically handles invoking both the\n * resource wrapper function as well as the underlying resource.\n *\n * _App-devs / consumers may not ever need to know this utility function exists_\n *\n *  Example using strict mode + `<template>` syntax and a template-only component:\n *  ```js\n *  import { resource, resourceFactory } from 'ember-resources';\n *\n *  const RemoteData = resourceFactory((url) => {\n *    return resource(({ on }) => {\n *      let state = new TrackedObject({});\n *      let controller = new AbortController();\n *\n *      on.cleanup(() => controller.abort());\n *\n *      fetch(url, { signal: controller.signal })\n *        .then(response => response.json())\n *        .then(data => {\n *          state.value = data;\n *        })\n *        .catch(error => {\n *          state.error = error;\n *        });\n *\n *      return state;\n *    })\n * });\n *\n *  <template>\n *    {{#let (RemoteData \"http://....\") as |state|}}\n *      {{#if state.value}}\n *        ...\n *      {{else if state.error}}\n *        {{state.error}}\n *      {{/if}}\n *    {{/let}}\n *  </template>\n *  ```\n *\n *  Alternatively, `resourceFactory` can wrap the wrapper function.\n *\n *  ```js\n *  const RemoteData = resourceFactory((url) => {\n *    return resource(({ on }) => {\n *      ...\n *    });\n *  })\n *  ```\n */\nexport function resourceFactory<Value = any, Args = any>(\n  wrapperFn: ResourceFactory<Value, Args>\n): (args: () => Args) => Value {\n  setHelperManager(ResourceInvokerFactory, wrapperFn);\n\n  return wrapperFn as unknown as (args: () => Args) => Value;\n}\n\n// Provide a singleton manager.\nconst ResourceInvokerFactory = (owner: Owner) => new ResourceInvokerManager(owner);\n"],"names":["ResourceInvokerManager","constructor","owner","_defineProperty","helperCapabilities","hasValue","hasDestroyable","createHelper","fn","args","cache","createCache","resource","positional","invokeHelper","_","getValue","associateDestroyableChild","getDestroyable","resourceFactory","wrapperFn","setHelperManager","ResourceInvokerFactory"],"mappings":";;;;;AAmBA,MAAMA,sBAAsB,CAAC;EAM3BC,WAAWA,CAAWC,KAAY,EAAE;AAAAC,IAAAA,eAAA,CALrBC,IAAAA,EAAAA,cAAAA,EAAAA,YAAkB,CAAC,MAAM,EAAE;AACxCC,MAAAA,QAAQ,EAAE,IAAI;AACdC,MAAAA,cAAc,EAAE,IAAA;AAClB,KAAC,CAAC,CAAA,CAAA;IAAA,IAEoBJ,CAAAA,KAAY,GAAZA,KAAY,CAAA;AAAG,GAAA;AAErCK,EAAAA,YAAYA,CAACC,EAAmB,EAAEC,IAAS,EAAS;AAClD;AACJ;AACA;AACA;AACA;AACA;AACI,IAAA,IAAIC,KAAK,GAAGC,WAAW,CAAC,MAAM;MAC5B,IAAIC,QAAQ,GAAGJ,EAAE,CAAC,GAAGC,IAAI,CAACI,UAAU,CAAW,CAAA;AAE/C,MAAA,OAAOC,YAAY,CAACJ,KAAK,EAAEE,QAAQ,CAAC,CAAA;AACtC,KAAC,CAAC,CAAA;IAGF,OAAO;MAAEJ,EAAE;MAAEC,IAAI;MAAEC,KAAK;MAAEK,CAAC,EAAEC,QAAQ,CAACN,KAAK,CAAA;KAAG,CAAA;AAChD,GAAA;;AAEA;AACF;AACA;AACEM,EAAAA,QAAQA,CAAC;AAAEN,IAAAA,KAAAA;AAAa,GAAC,EAAE;AACzB,IAAA,IAAIE,QAAQ,GAAGI,QAAQ,CAACN,KAAK,CAAC,CAAA;AAE9BO,IAAAA,yBAAyB,CAACP,KAAK,EAAEE,QAAQ,CAAC,CAAA;IAE1C,OAAOI,QAAQ,CAACJ,QAAQ,CAAC,CAAA;AAC3B,GAAA;AAEAM,EAAAA,cAAcA,CAAC;AAAER,IAAAA,KAAAA;AAAa,GAAC,EAAE;AAC/B,IAAA,OAAOA,KAAK,CAAA;AACd,GAAA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACF,CAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASS,eAAeA,CAC7BC,SAAuC,EACV;AAC7BC,EAAAA,gBAAgB,CAACC,sBAAsB,EAAEF,SAAS,CAAC,CAAA;AAEnD,EAAA,OAAOA,SAAS,CAAA;AAClB,CAAA;;AAEA;AACA,MAAME,sBAAsB,GAAIpB,KAAY,IAAK,IAAIF,sBAAsB,CAACE,KAAK,CAAC;;;;"}